'From Pharo10.0.0 of 1 March 2024 [Build information: Pharo-10.0.0+build.539.sha.28169ae414c78e07602b31545f43061b4fa7a88a (64 Bit)] on 20 February 2025 at 3:13:21.463 pm'!Object subclass: #Polarity	instanceVariableNames: ''	classVariableNames: ''	package: 'CPS506'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Polarity class	instanceVariableNames: 'steps'!!Polarity class methodsFor: 'printing' stamp: 'AhmadJouhar 2/20/2025 01:57'!printList: rules cons: consrules do: [ :line |    Transcript show: (line inject: '' into: [ :acc :char | acc , char asString , ' ' ]); cr.].cons keysAndValuesDo: [ :key :value |    Transcript show: key, ' -> ', value printString; cr.].Transcript cr.! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'AhmadJouhar 2/20/2025 01:41'!revertRequirementsVertically: constraints i: i j: j pattern: pat    | right left top bottom first |    right := constraints at: 'right'.    left := constraints at: 'left'.    top := constraints at: 'top'.    bottom := constraints at: 'bottom'.        first := pat at: 1.        first = $+ ifTrue: [        top at: j put: ((top at: j) + 1).        left at: i put: ((left at: i) + 1).        bottom at: j put: ((bottom at: j) + 1).        right at: i+1 put: ((right at: i+1) + 1).    ].        first = $- ifTrue: [        top at: j put: ((top at: j) + 1).        left at: i+1 put: ((left at: i+1) + 1).        bottom at: j put: ((bottom at: j) + 1).        right at: i put: ((right at: i) + 1).    ].! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'AhmadJouhar 2/20/2025 11:55'!revertRequirementsHorizontally: constraints i: i j: j pattern: pat    | right left top bottom first |    right := constraints at: 'right'.    left := constraints at: 'left'.    top := constraints at: 'top'.    bottom := constraints at: 'bottom'.        first := pat at: 1.    first = $+ ifTrue: [        top at: j put: ((top at: j) + 1).        left at: i put: ((left at: i) + 1).        bottom at: j+1 put: ((bottom at: j+1) + 1).        right at: i put: ((right at: i) + 1).    ].    first = $- ifTrue: [        top at: j+1 put: ((top at: j+1) + 1).        left at: i put: ((left at: i) + 1).        bottom at: j put: ((bottom at: j) + 1).        right at: i put: ((right at: i) + 1).    ].! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'AhmadJouhar 2/20/2025 01:42'!revertUpdates: rules changes: changes    1 to: changes size do: [ :i |        1 to: (changes first size) do: [ :j |            ((changes at: i) at: j) ~= 0 ifTrue: [     				(rules at: i) at: j put: ((changes at: i) at: j).            ].        ].    ].! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'AhmadJouhar 2/20/2025 12:29'!solveWith: board and: specs	| newSpecs newBoard |	" 	The solution to board 1 is hard-coded below, just to demonstrate  	  	what the return format should look like. It will pass the first	  	test like this, but you may NOT leave it like this. Hardcoding is		not allowed.  "		newSpecs := Dictionary new.	specs keysDo: [ :key |  		newSpecs at: key put: (Array withAll: (specs at: key)).	].steps :=0.	newBoard := Array new: (board size).	board withIndexDo: [ :element :index | 		newBoard at: index put: element asString copy.	].	self updateWithXs: newBoard constraints: newSpecs.	"1"  ^ self solveMagnets: newBoard constraints: newSpecs i: 1 j: 1 	! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'AhmadJouhar 2/20/2025 15:09'!updateWithXs: rules constraints: constraints    | right left top bottom changes |    right := constraints at: 'right'.    left := constraints at: 'left'.    top := constraints at: 'top'.    bottom := constraints at: 'bottom'.    changes := (1 to: rules size) collect: [ :i | (Array new: (rules first size) withAll: 0) ].    "Row-wise processing"    1 to: (left size) do: [ :i |	        ((((left at: i) = 0) and: ((right at: i) = 0))) ifTrue: [				1 to: (rules first size) do: [ :j |                | char |                char := (rules at: i) at: j.                 (('TBLR' asArray) includes: char) ifTrue: [                    (rules at: i) at: j put: $X.                    (changes at: i) at: j put: char.                    (char = $T) ifTrue: [                        (rules at: i+1) at: j put: $X.                        (changes at: i+1) at: j put: $B.                    ].                    (char = $B) ifTrue: [                        (rules at: i-1) at: j put: $X.                        (changes at: i-1) at: j put: $T.                    ].                ].            ].        ].        (((left at: i) = 0) or: ((right at: i) = 0)) ifTrue: [            1 to: (rules first size) do: [ :j |                (((rules at: i) at: j) = $R) ifTrue: [                    (rules at: i) at: j put: $X.                    (changes at: i) at: j put: $R.                ].                (((rules at: i) at: j) = $L) ifTrue: [                    (rules at: i) at: j put: $X.                    (changes at: i) at: j put: $L.                ].            ].        ].        (i < left size) ifTrue: [            (((left at: i) = 0 and: (left at: i+1) = 0)                 or: ((right at: i) = 0 and: (right at: i+1) = 0)) ifTrue: [                    1 to: (rules first size) do: [ :j |                        (((rules at: i) at: j) = $T) ifTrue: [                            (rules at: i) at: j put: $X.                            (rules at: i+1) at: j put: $X.                            (changes at: i) at: j put: $T.                            (changes at: i+1) at: j put: $B.                        ].                    ].                ].        ].    ].    "Column-wise processing"    1 to: top size do: [ :j |        (((top at: j) = 0) and: ((bottom at: j) = 0)) ifTrue: [            1 to: rules size do: [ :i |                | char |                char := (rules at: i) at: j.                (('TBLR' asArray) includes: char) ifTrue: [                    (rules at: i) at: j put: $X.                    (changes at: i) at: j put: char.                    (char = $L) ifTrue: [                        (rules at: i) at: j+1 put: $X.                        (changes at: i) at: j+1 put: $R.                    ].                    (char = $R) ifTrue: [                        (rules at: i) at: j-1 put: $X.                        (changes at: i) at: j-1 put: $L.                    ].                ].            ].        ].         (((top at: j) = 0) or: ((bottom at: j) = 0)) ifTrue: [            1 to: rules size do: [ :i |                (((rules at: i) at: j) = $B) ifTrue: [                    (rules at: i) at: j put: $X.                    (changes at: i) at: j put: $B.                ].                (((rules at: i) at: j) = $T) ifTrue: [                    (rules at: i) at: j put: $X.                    (changes at: i) at: j put: $T.                ].            ].        ].        (j < (top size)) ifTrue: [            ((((top at: j) = 0) and: ((top at: j+1) = 0))                 or: (((bottom at: j) = 0) and: ((bottom at: j+1) = 0))) ifTrue: [                    1 to: (rules size) do: [ :i |                        (((rules at: i) at: j) = $L) ifTrue: [                             (rules at: i) at: j put: $X.                            (rules at: i) at: j+1 put: $X.                            (changes at: i) at: j put: $L.                            (changes at: i) at: j+1 put: $R.                        ].                    ].                ].        ].    ].    ^ changes.! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'AhmadJouhar 2/20/2025 15:11'!solveMagnets: rules constraints: constraints i: iorg j: jorg    "Recursive backtracking function to solve the magnet puzzle"	    | sol changes i j arr |steps := steps+1.	i:=iorg.	j:=jorg.	(steps = 10000) ifTrue: [ ^'doesnt work' ].    (self isSolvable: rules constraints: constraints) ifFalse: [ ^ nil ].    (self isDone: constraints) ifTrue: [		  Transcript show: 'Done in '; show: steps; show: ' steps';cr.		  self fillEmptyCells: rules.		  self printList: rules cons: constraints.        ^ rules.    ].    (j > (rules first size)) ifTrue: [        "Move to next row when reaching the end of a row"        ^ self solveMagnets: rules constraints: constraints i: i+1 j: 1.    ].    (i > (rules size)) ifTrue: [        "Move to next row when reaching the end of a row"        ^ nil.    ].    "Find the next empty slot"    [ ((('TLBR' asArray) includes: ((rules at: i) at: j)) not) ] whileTrue: [        j := j + 1.        (j > (rules first size)) ifTrue: [            j := 1.            i := i + 1.        ].        (i = ((rules size)+1)) ifTrue: [            (self isDone: constraints) ifTrue: [                self updateWithXs: rules constraints: constraints.                ^ rules.            ] ifFalse: [ ^ nil ].        ].    ].    "Try placing horizontal magnet"    ( (rules at: i) at: j ) = $L ifTrue: [			arr := (Array with: i with: j).        (self canPutPatternHorizontally: rules constraints: constraints ij: arr pattern: '+-') ifTrue: [            self adjustRequirementsHorizontally: constraints i: i j: j pattern: '+-'.            (rules at: i) at: j put: $+.            (rules at: i) at: j+1 put: $-.            changes := self updateWithXs: rules constraints: constraints.            sol := self solveMagnets: rules constraints: constraints i: i j: j+2.            sol ifNotNil: [ ^ sol ].            self revertUpdates: rules changes: changes.            self revertRequirementsHorizontally: constraints i: i j: j pattern: '+-'.            (rules at: i) at: j put: $L.            (rules at: i) at: j+1 put: $R.        ].        (self canPutPatternHorizontally: rules constraints: constraints ij: arr pattern: '-+') ifTrue: [     				self adjustRequirementsHorizontally: constraints i: i j: j pattern: '-+'.            (rules at: i) at: j put: $-.            (rules at: i) at: j+1 put: $+.            changes := self updateWithXs: rules constraints: constraints.            sol := self solveMagnets: rules constraints: constraints i: i j: j+2.            sol ifNotNil: [ ^ sol ].            self revertUpdates: rules changes: changes.            self revertRequirementsHorizontally: constraints i: i j: j pattern: '-+'.            (rules at: i) at: j put: $L.            (rules at: i) at: j+1 put: $R.        ].        (rules at: i) at: j put: $X.        (rules at: i) at: j+1 put: $X.        sol := self solveMagnets: rules constraints: constraints i: i j: j+2.        sol ifNotNil: [ ^ sol ].        (rules at: i) at: j put: $L.        (rules at: i) at: j+1 put: $R.    ].    "Try placing vertical magnet"    ( (rules at: i) at: j ) = $T ifTrue: [		arr := (Array with: i with: j).        (self canPutPatternVertically: rules constraints: constraints ij: arr pattern: '+-') ifTrue: [            self adjustRequirementsVertically: constraints i: i j: j pattern: '+-'.            (rules at: i) at: j put: $+.            (rules at: i+1) at: j put: $-.            changes := self updateWithXs: rules constraints: constraints.            sol := self solveMagnets: rules constraints: constraints i: i j: j+1.            sol ifNotNil: [ ^ sol ].            self revertUpdates: rules changes: changes.            self revertRequirementsVertically: constraints i: i j: j pattern: '+-'.            (rules at: i) at: j put: $T.            (rules at: i+1) at: j put: $B.        ].        (self canPutPatternVertically: rules constraints: constraints ij: arr pattern: '-+') ifTrue: [            self adjustRequirementsVertically: constraints i: i j: j pattern: '-+'.            (rules at: i) at: j put: $-.            (rules at: i+1) at: j put: $+.            changes := self updateWithXs: rules constraints: constraints.            sol := self solveMagnets: rules constraints: constraints i: i j: j+1.            sol ifNotNil: [ ^ sol ].            self revertUpdates: rules changes: changes.            self revertRequirementsVertically: constraints i: i j: j pattern: '-+'.            (rules at: i) at: j put: $T.            (rules at: i+1) at: j put: $B.        ].        (rules at: i) at: j put: $X.        (rules at: i+1) at: j put: $X.        sol := self solveMagnets: rules constraints: constraints i: i j: j+1.        sol ifNotNil: [ ^ sol ].        (rules at: i) at: j put: $T.        (rules at: i+1) at: j put: $B.    ].    "Move to the next cell"    ^ nil.! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'AhmadJouhar 2/20/2025 01:41'!adjustRequirementsVertically: constraints i: i j: j pattern: pat    | right left top bottom first |    right := constraints at: 'right'.    left := constraints at: 'left'.    top := constraints at: 'top'.    bottom := constraints at: 'bottom'.        first := pat at: 1.        first = $+ ifTrue: [        top at: j put: ((top at: j) - 1).        left at: i put: ((left at: i) - 1).        bottom at: j put: ((bottom at: j) - 1).        right at: i+1 put: ((right at: i+1) - 1).    ].        first = $- ifTrue: [        top at: j put: ((top at: j) - 1).        left at: i+1 put: ((left at: i+1) - 1).        bottom at: j put: ((bottom at: j) - 1).        right at: i put: ((right at: i) - 1).    ].! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'AhmadJouhar 2/20/2025 01:41'!adjustRequirementsHorizontally: constraints i: i j: j pattern: pat    | right left top bottom first |    right := constraints at: 'right'.    left := constraints at: 'left'.    top := constraints at: 'top'.    bottom := constraints at: 'bottom'.        first := pat at: 1.        first = $+ ifTrue: [        top at: j put: ((top at: j) - 1).        left at: i put: ((left at: i) - 1).        bottom at: j+1 put: ((bottom at: j+1) - 1).        right at: i put: ((right at: i) - 1).    ].        first = $- ifTrue: [        top at: j+1 put: ((top at: j+1) - 1).        left at: i put: ((left at: i) - 1).        bottom at: j put: ((bottom at: j) - 1).        right at: i put: ((right at: i) - 1).    ].! !!Polarity class methodsFor: 'as yet unclassified' stamp: 'AhmadJouhar 2/20/2025 15:10'!fillEmptyCells: rules    1 to: rules size do: [ :i |        1 to: (rules first size) do: [ :j |            ((('TBLR' asArray) includes: ((rules at: i) at: j))) ifTrue: [                (rules at: i) at: j put: $X.            ].        ].    ].! !!Polarity class methodsFor: 'testing' stamp: 'AhmadJouhar 2/20/2025 01:41'!canPutPatternVertically: rules constraints: constraints ij: ij pattern: pat    | right left top bottom i j|    right := constraints at: 'right'.    left := constraints at: 'left'.    top := constraints at: 'top'.    bottom := constraints at: 'bottom'.    	 i := (ij at: 1).	 j := (ij at: 2).    "Checks if a vertical magnet pattern can be placed at position (i, j)"    ((pat asArray) first = $+) ifTrue: ["	Transcript show: 'error here';cr."        (((top at: j) = 0) or: [(left at: i) = 0 or: [(bottom at: j) = 0 or: [(right at: i+1) = 0]]])        ifTrue: [ ^false ].    ].    (pat first = $-) ifTrue: [        ((top at: j) = 0 or: [(left at: i+1) = 0 or: [(bottom at: j) = 0 or: [(right at: i) = 0]]])        ifTrue: [ ^false ].    ].    (j > 1) ifTrue: [        (((rules at: i) at: j-1) = pat first or: [((rules at: i+1) at: j-1) = pat second]) ifTrue: [ ^false ].    ].    (j < (rules first size)) ifTrue: [        (((rules at: i) at: j+1) = pat first or: [((rules at: i+1) at: j+1) = pat second]) ifTrue: [ ^false ].    ].    (i > 1) ifTrue: [        ((rules at: i-1) at: j) = pat first ifTrue: [ ^false ].    ].    ((i+2) < ((rules size)+1)) ifTrue: [        ((rules at: i+2) at: j) = pat second ifTrue: [ ^false ].    ].        ^true.! !!Polarity class methodsFor: 'testing' stamp: 'AhmadJouhar 2/20/2025 01:42'!isSolvable: rules constraints: constraints    | right left top bottom score pOffset nOffset i j cell arr |    right := constraints at: 'right'.    left := constraints at: 'left'.    top := constraints at: 'top'.    bottom := constraints at: 'bottom'.    score := 0.    pOffset := 0.    nOffset := 0.    i := 1.    j := 1.    "Check row constraints"	 arr:=(Array with: i with: j).    left do: [ :item |        (rules at: i) do: [ :cellR |            (('RL' asArray) includes: cellR) ifTrue: [                score := score + 0.5.                (cellR = $L) ifTrue: [	arr:=(Array with: i with: j).                    ((self canPutPatternHorizontally: rules constraints: constraints ij: arr pattern: '+-')                     or: (self canPutPatternHorizontally: rules constraints: constraints ij: arr pattern: '-+')) ifFalse: [                        pOffset := pOffset + 1.                        nOffset := nOffset + 1.                     ].                ].            ].            ('TB' includes: cellR) ifTrue: [                score := score + 1.                (cellR = $T) ifTrue: [	arr:=(Array with: i with: j).                    (self canPutPatternVertically: rules constraints: constraints ij: arr pattern: '+-') ifFalse: [ pOffset := pOffset + 1 ].                    (self canPutPatternVertically: rules constraints: constraints ij: arr pattern: '-+') ifFalse: [ nOffset := nOffset + 1 ].                ].                (cellR = $B) ifTrue: [	arr:= (Array with: i-1 with: j).                    (self canPutPatternVertically: rules constraints: constraints ij: arr pattern: '+-') ifFalse: [ nOffset := nOffset + 1 ].                    (self canPutPatternVertically: rules constraints: constraints ij: arr pattern: '-+') ifFalse: [ pOffset := pOffset + 1 ].                ].            ].            j := j + 1.        ].        score := score rounded."			Transcript show: score; show: ', '; show: pOffset; show: ', '; show: nOffset;cr;cr."        ((item >= 0 and: ((score - pOffset) < item))          or: ((right at: i) >= 0 and: ((score - nOffset) < (right at: i)))) ifTrue: [ ^ false ].        score := 0.        nOffset := 0.        pOffset := 0.        j := 1.        i := i + 1.    ].    "Check column constraints"    score := 0.    pOffset := 0.    nOffset := 0.    j := 1.    i := 1.    top do: [ :item |        rules do: [ :row |            cell := row at: j.            ('TB' includes: cell) ifTrue: [                score := score + 0.5.                (cell = $T) ifTrue: [	arr := (Array with: i with: j).                    ((self canPutPatternVertically: rules constraints: constraints ij: arr pattern: '+-') not                     and: (self canPutPatternVertically: rules constraints: constraints ij: arr pattern: '-+') not) ifTrue: [                        pOffset := pOffset + 1.                        nOffset := nOffset + 1.                    ].                ].            ].            ('LR' includes: cell) ifTrue: [                score := score + 1.                (cell = $L) ifTrue: [arr:=(Array with: i with: j).                    (self canPutPatternHorizontally: rules constraints: constraints ij: arr pattern: '+-') ifFalse: [ pOffset := pOffset + 1 ].                    (self canPutPatternHorizontally: rules constraints: constraints ij: arr pattern: '-+') ifFalse: [ nOffset := nOffset + 1 ].                ].                (cell = $R) ifTrue: [	arr := (Array with: i with: j-1).                    (self canPutPatternHorizontally: rules constraints: constraints ij: arr pattern: '+-') ifFalse: [ nOffset := nOffset + 1 ].                    (self canPutPatternHorizontally: rules constraints: constraints ij: arr pattern: '-+') ifFalse: [ pOffset := pOffset + 1 ].                ].            ].            i := i + 1.        ].         score := score rounded."Transcript show: score; show: ', '; show: pOffset; show: ', '; show: nOffset;cr;cr."        ((item >= 0 and: ((score - pOffset) < item))          or: ((bottom at: j) >= 0 and: ((score - nOffset) < (bottom at: j)))) ifTrue: [ ^ false ].        score := 0.        nOffset := 0.        pOffset := 0.        j := j + 1.        i := 1.    ].    ^ true.! !!Polarity class methodsFor: 'testing' stamp: 'AhmadJouhar 2/20/2025 01:41'!isDone: constraints    | right left top bottom |    right := constraints at: 'right'.    left := constraints at: 'left'.    top := constraints at: 'top'.    bottom := constraints at: 'bottom'.        left do: [ :element | element > 0 ifTrue: [ ^false ] ].    right do: [ :element | element > 0 ifTrue: [ ^false ] ].    top do: [ :element | element > 0 ifTrue: [ ^false ] ].    bottom do: [ :element | element > 0 ifTrue: [ ^false ] ].    ^true.! !!Polarity class methodsFor: 'testing' stamp: 'AhmadJouhar 2/20/2025 01:41'!canPutPatternHorizontally: rules constraints: constraints ij: ij pattern: pat    | right left top bottom i j|    right := constraints at: 'right'.    left := constraints at: 'left'.    top := constraints at: 'top'.    bottom := constraints at: 'bottom'.    	 i := (ij at: 1).	 j := (ij at: 2).	    "Checks if a horizontal magnet pattern can be placed at position (i, j)" 	(pat first = $+) ifTrue: [        ((top at: j) = 0 or: [(left at: i) = 0 or: [(bottom at: j+1) = 0 or: [(right at: i) = 0]]])        ifTrue: [ ^false ].    ].    (pat first = $-) ifTrue: [        ((top at: j+1) = 0 or: [(left at: i) = 0 or: [(bottom at: j) = 0 or: [(right at: i) = 0]]])        ifTrue: [ ^false ].    ].        (i > 1) ifTrue: [        "checking above neighbors"        ((((rules at: i-1) at: j) = pat first) or: [((rules at: i-1) at: j+1) = pat second]) ifTrue: [ ^false ].    ].    (i < (rules size)) ifTrue: [        "checking below neighbors"        ((((rules at: i+1) at: j) = pat first) or: [((rules at: i+1) at: j+1) = pat second]) ifTrue: [ ^false ].    ].    ((j-1) >= 1) ifTrue: [        ((rules at: i) at: j-1) = pat first ifTrue: [ ^false ].    ].        ((j+2) <= (rules first size)) ifTrue: [        ((rules at: i) at: j+2) = pat second ifTrue: [ ^false ].    ].        ^true.! !